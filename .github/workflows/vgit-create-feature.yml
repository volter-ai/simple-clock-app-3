name: VGit Create Feature
on:
  workflow_dispatch:
    inputs:
      branch_name:
        description: "Name for the new branch"
        required: true
        type: string
      request:
        description: "Feature request description"
        required: true
        type: string
      username:
        description: "GitHub username"
        required: true
        type: string
      current_node:
        description: "Current workspace node (optional)"
        required: false
        type: string
      base_branch:
        description: "Base branch to create feature from"
        required: false
        type: string
        default: "main"
      environment:
        description: "GitHub environment to use for deployment"
        required: false
        type: string
      runtime_vars:
        description: "Comma-separated list of env var names to expose at runtime"
        required: false
        type: string
        default: ""

jobs:
  create-feature:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    environment: ${{ github.event.inputs.environment || '' }}
    permissions:
      contents: write # For git operations (checkout, commit, push)
      actions: read # For workflow operations

    steps:
      - name: Validate inputs
        run: |
          if [ -z "${{ github.event.inputs.branch_name }}" ]; then
            echo "âŒ Branch name is required"
            exit 1
          fi
          if [ -z "${{ github.event.inputs.request }}" ]; then
            echo "âŒ Feature request is required"
            exit 1
          fi
          echo "âœ… Inputs validated"
          echo "Branch: ${{ github.event.inputs.branch_name }}"
          echo "Request: ${{ github.event.inputs.request }}"

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure Git
        run: |
          git config --global user.name "${{ github.event.inputs.username }}"
          git config --global user.email "${{ github.event.inputs.username }}@users.noreply.github.com"

      - name: Create feature branch
        run: |
          echo "ğŸŒ¿ Creating feature branch: ${{ github.event.inputs.branch_name }}"

          # Ensure we're on the base branch
          git checkout ${{ github.event.inputs.base_branch }}
          git pull origin ${{ github.event.inputs.base_branch }}

          # Create and switch to feature branch
          git checkout -b "${{ github.event.inputs.branch_name }}"

          echo "âœ… Feature branch created successfully"
      - name: Update commit with pending preview info
        run: |
          echo "ğŸ“ Starting feature request"

          # Amend commit with preview information
          UPDATED_COMMIT_MSG="feat: ${{ github.event.inputs.request }}

          ğŸ¤– Generated with VGit AI (Claude Code)

          Branch: ${{ github.event.inputs.branch_name }}
          Requested by: ${{ github.event.inputs.username }}

          ---PREVIEW-INFO---
          Preview URL: still_pending
          Screenshot URL: still_pending
          "

          git commit --amend -m "$UPDATED_COMMIT_MSG"
          git push origin "${{ github.event.inputs.branch_name }}" --force-with-lease
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"

      - name: Install dependencies
        run: |
          if [ -f "package.json" ]; then
            echo "ğŸ“¦ Installing dependencies..."
            npm install
          else
            echo "âš ï¸ No package.json found, skipping dependency installation"
          fi

      - name: Export all secrets as environment variables dynamically
        run: |
          echo "ğŸ” Dynamically exporting all secrets as environment variables..."
          if [ "$SECRETS_JSON" != "null" ] && [ "$SECRETS_JSON" != "" ]; then
            echo "ğŸ“‹ Processing secrets from environment..."
            echo "$SECRETS_JSON" | jq -r 'to_entries | .[] | "\(.key)=\(.value)"' >> $GITHUB_ENV
            echo "âœ… All secrets exported as environment variables"
          else
            echo "â„¹ï¸ No secrets found in environment"
          fi
        env:
          SECRETS_JSON: ${{ toJson(secrets) }}

      - name: Prepare runtime environment variables
        run: |
          echo "ğŸ”§ Preparing runtime environment variables..."
          
          # Debug: Show which environment variables are available (names only, not values)
          echo "ğŸ” Available environment variables (for debugging):"
          env | grep -E '^(ANTHROPIC|SUBSCRIBE|OPENAI|CUSTOM)' | cut -d'=' -f1 | sort || echo "No addon-related environment variables found"
          
          # Parse runtime_vars input (comma-separated list)
          RUNTIME_VARS="${{ github.event.inputs.runtime_vars }}"
          
          if [ -n "$RUNTIME_VARS" ] && [ "$RUNTIME_VARS" != "" ]; then
            echo "ğŸ“‹ Runtime variables to expose: $RUNTIME_VARS"
            
            # Create a script to export VITE_ prefixed versions
            echo "#!/bin/bash" > runtime_env_setup.sh
            echo "# Auto-generated runtime environment variables" >> runtime_env_setup.sh
            
            # Split comma-separated values and create VITE_ versions
            IFS=',' read -ra VARS <<< "$RUNTIME_VARS"
            for var in "${VARS[@]}"; do
              # Trim whitespace
              var=$(echo "$var" | xargs)
              
              if [ -n "$var" ]; then
                # Convert to uppercase
                upper_var=$(echo "$var" | tr '[:lower:]' '[:upper:]')
                vite_var="VITE_$upper_var"
                
                echo "Creating runtime variable: $upper_var -> $vite_var"
                
                # Add export statement to script
                echo "if [ -n \"\${$upper_var}\" ]; then" >> runtime_env_setup.sh
                echo "  export $vite_var=\"\${$upper_var}\"" >> runtime_env_setup.sh
                echo "  echo \"âœ… Exposed $upper_var as $vite_var\"" >> runtime_env_setup.sh
                echo "else" >> runtime_env_setup.sh
                echo "  echo \"âš ï¸ $upper_var not found in environment\"" >> runtime_env_setup.sh
                echo "fi" >> runtime_env_setup.sh
              fi
            done
            
            # Make the script executable
            chmod +x runtime_env_setup.sh
            
            echo "ğŸ” Runtime environment setup script created:"
            cat runtime_env_setup.sh
          else
            echo "â„¹ï¸ No runtime variables specified, skipping VITE_ prefix setup"
            echo "#!/bin/bash" > runtime_env_setup.sh
            echo "echo 'No runtime variables to expose'" >> runtime_env_setup.sh
            chmod +x runtime_env_setup.sh
          fi

      - name: Install Claude Code CLI
        run: |
          echo "ğŸ“¦ Installing Claude Code CLI..."
          npm install -g @anthropic-ai/claude-code
          echo "âœ… Claude Code CLI installed"
          claude --version

      - name: Check for CLAUDE.md
        run: |
          echo "ğŸ“„ Checking for CLAUDE.md project instructions..."
          if [ -f "CLAUDE.md" ]; then
            echo "âœ… Found CLAUDE.md - Claude Code will use project-specific instructions"
            wc -l CLAUDE.md | awk '{print "  Lines:", $1}'
          else
            echo "â„¹ï¸ No CLAUDE.md found - using generic instructions"
          fi

      - name: Implement feature with Claude Code CLI
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        run: |
          echo "ğŸ¤– Running Claude Code CLI to implement feature..."

          # Create prompt file
          cat > feature_prompt.txt << 'PROMPT_EOF'
          Please implement the following feature request:

          **Feature Request:** ${{ github.event.inputs.request }}

          **Project Context:**
          - Repository: ${{ github.repository }}
          - Branch: ${{ github.event.inputs.branch_name }}
          - Base Branch: ${{ github.event.inputs.base_branch }}
          - Requested by: ${{ github.event.inputs.username }}

          **CRITICAL - Read Project Instructions First:**
          1. Check if there is a CLAUDE.md file in the repository root
          2. If CLAUDE.md exists, READ IT FIRST and follow ALL guidelines specified there
          3. The CLAUDE.md file contains critical project-specific instructions, architecture details, and conventions
          4. All implementation decisions should follow the patterns and guidelines in CLAUDE.md

          **Implementation Steps:**
          1. Read CLAUDE.md if it exists (this is mandatory!)
          2. Analyze the existing codebase structure and patterns (check existing components, styling approach, state management)
          3. Implement the feature following the project's conventions from CLAUDE.md
          4. If you need to add dependencies, update package.json accordingly
          5. Ensure the code compiles and follows best practices
          6. Make minimal, focused changes that accomplish the feature request

          **Frontend/UI Implementation Best Practices:**
          When implementing UI features, pages, or components:

          - **Layout & Spacing:**
            - Use fullscreen layouts when appropriate (min-h-screen, w-full, h-full)
            - Implement proper responsive design with mobile-first approach
            - Use consistent spacing (padding, margin) following the project's design system
            - Utilize flexbox/grid for layouts (flex, grid, gap utilities)

          - **Styling & Visual Design:**
            - Follow the existing styling approach (CSS Modules, Tailwind, styled-components, etc.)
            - Maintain consistent color palette and theming from existing components
            - Add smooth transitions and hover states for interactive elements
            - Ensure proper contrast ratios for accessibility (WCAG AA minimum)
            - Use semantic color names (primary, secondary, accent, etc.)

          - **Component Architecture:**
            - Create reusable, composable components
            - Separate presentation from business logic
            - Use TypeScript interfaces for all component props
            - Implement proper loading states, error boundaries, and empty states
            - Follow existing file structure and naming conventions

          - **User Experience:**
            - Add loading spinners or skeletons for async operations
            - Implement proper error handling with user-friendly messages
            - Provide visual feedback for user actions (button states, form validation)
            - Ensure keyboard navigation and focus management
            - Add appropriate aria-labels for accessibility

          - **Modern UI Patterns:**
            - Use CSS Grid/Flexbox for complex layouts
            - Implement proper z-index layering for modals, dropdowns, tooltips
            - Add smooth animations (transform, opacity) not layout shifts
            - Use CSS variables for theming support
            - Implement dark mode support if the project has it

          - **Performance:**
            - Lazy load components when appropriate
            - Optimize images (proper formats, sizes, lazy loading)
            - Avoid unnecessary re-renders (useMemo, useCallback, React.memo)
            - Use code splitting for large features

          **Important Quality Checks:**
          - CLAUDE.md is your primary source of truth for this project
          - Always assume environment variables are available, and never leave situations where env vars are needed as mocked or TODO or placeholders. Environment variables are always there.
          - Ensure all changes are production-ready and fully functional
          - Test edge cases and error scenarios
          - Verify responsive behavior across screen sizes
          - Do not make unnecessary changes outside the feature scope
          - Match the quality and style of existing components

          Start by reading CLAUDE.md (if present), then implement the feature with professional-grade UI/UX.
          PROMPT_EOF

          # Run Claude Code CLI with the prompt
          # The CLI will automatically detect and use CLAUDE.md through the prompt instructions
          claude --output-format text --verbose --allowedTools Edit,Read,Write,Glob,Grep,"Bash(npm install:*)","Bash(npm i:*)" < feature_prompt.txt || {
            echo "âš ï¸ Claude Code CLI execution had issues, checking for changes..."
          }

          echo "âœ… Claude Code CLI execution completed"

      - name: Install new dependencies (if package.json changed)
        run: |
          cat package.json
        
          if git diff --name-only | grep -q "package.json"; then
            echo "ğŸ“¦ package.json was modified, installing new dependencies..."
            npm install
          else
            echo "â„¹ï¸ No package.json changes detected"
          fi

      - name: Verify changes
        run: |
          echo "ğŸ” Verifying implemented changes..."

          # Check if any files were modified
          if git diff --quiet; then
            echo "âš ï¸ No changes detected. Creating a minimal change to complete the workflow."
            echo "# Feature: ${{ github.event.inputs.request }}" >> FEATURE_LOG.md
            echo "- Implemented on: $(date)" >> FEATURE_LOG.md
            echo "- Branch: ${{ github.event.inputs.branch_name }}" >> FEATURE_LOG.md
            echo "" >> FEATURE_LOG.md
          else
            echo "âœ… Changes detected:"
            git diff --name-only
          fi

      - name: Run tests (if available)
        run: |
          echo "ğŸ§ª Running tests..."
          if [ -f "package.json" ] && grep -q '"test"' package.json; then
            npm test || {
              echo "âš ï¸ Tests failed, but continuing with feature implementation"
              echo "TEST_FAILURES=true" >> $GITHUB_ENV
            }
          else
            echo "â„¹ï¸ No test script found, skipping tests"
          fi

      - name: Commit changes
        run: |
          echo "ğŸ“ Committing changes..."

          # Add all changes
          git add .

          # Create commit message
          COMMIT_MSG="feat: ${{ github.event.inputs.request }}

          ğŸ¤– Generated with VGit AI (Claude Code)

          Branch: ${{ github.event.inputs.branch_name }}
          Requested by: ${{ github.event.inputs.username }}

          Co-Authored-By: Claude Code <ai@vgit.app>"

          # Commit changes
          git commit -m "$COMMIT_MSG" || {
            echo "âŒ Commit failed"
            exit 1
          }

          echo "âœ… Changes committed successfully"

      - name: Push feature branch
        run: |
          echo "ğŸš€ Pushing feature branch to origin..."
          git push origin "${{ github.event.inputs.branch_name }}" || {
            echo "âŒ Push failed"
            exit 1
          }
          echo "âœ… Feature branch pushed successfully"

      - name: Create deployment preview (if applicable)
        run: |
          echo "ğŸŒ Creating deployment preview..."

          # Check if this is a web project that can be deployed
          if [ -f "package.json" ] && (grep -q '"build"' package.json || grep -q '"dev"' package.json); then
            echo "ğŸ“¦ Web project detected, attempting preview deployment..."
            
            # Build the project with runtime environment variables
            if grep -q '"build"' package.json; then
              echo "ğŸ” Re-exporting secrets for build step..."
              if [ "$SECRETS_JSON" != "null" ] && [ "$SECRETS_JSON" != "" ]; then
                eval $(echo "$SECRETS_JSON" | jq -r 'to_entries | .[] | "export \(.key)=\"\(.value)\""')
                echo "âœ… Secrets re-exported for build step"
              fi
              
              echo "ğŸ”§ Sourcing runtime environment variables before build..."
              source ./runtime_env_setup.sh
              
              npm run build && {
                echo "PREVIEW_BUILD_SUCCESS=true" >> $GITHUB_ENV
                echo "âœ… Build successful"
              } || {
                echo "âš ï¸ Build failed, skipping preview deployment"
                echo "PREVIEW_BUILD_SUCCESS=false" >> $GITHUB_ENV
              }
            else
              echo "â„¹ï¸ No build script found, skipping preview"
              echo "PREVIEW_BUILD_SUCCESS=false" >> $GITHUB_ENV
            fi
          else
            echo "â„¹ï¸ Not a web project, skipping preview deployment"
            echo "PREVIEW_BUILD_SUCCESS=false" >> $GITHUB_ENV
          fi
        env:
          SECRETS_JSON: ${{ toJson(secrets) }}

      - name: Detect build output directory
        if: env.PREVIEW_BUILD_SUCCESS == 'true'
        run: |
          echo "ğŸ“ Detecting build output directory..."

          # Check for custom build directory from secret first
          if [ -n "${{ secrets.CUSTOM_BUILD_DIR }}" ]; then
            CUSTOM_DIR="${{ secrets.CUSTOM_BUILD_DIR }}"
            if [ -d "$CUSTOM_DIR" ] && [ "$(ls -A $CUSTOM_DIR 2>/dev/null)" ]; then
              BUILD_DIR="$CUSTOM_DIR"
              echo "BUILD_DIR=$CUSTOM_DIR" >> $GITHUB_ENV
              echo "âœ… Using custom build directory: $CUSTOM_DIR"
              ls -la "$CUSTOM_DIR"
              exit 0
            else
              echo "âš ï¸ Custom build directory '$CUSTOM_DIR' not found or empty, falling back to auto-detection"
            fi
          fi

          # Auto-detect common build output directories
          BUILD_DIRS=("dist" "build" "_site" "out" ".next" "public")

          for dir in "${BUILD_DIRS[@]}"; do
            if [ -d "$dir" ] && [ "$(ls -A $dir 2>/dev/null)" ]; then
              BUILD_DIR="$dir"
              echo "BUILD_DIR=$dir" >> $GITHUB_ENV
              echo "âœ… Build output directory found: $dir"
              break
            fi
          done

          # If no build directory found, use current directory for static sites
          if [ -z "${BUILD_DIR:-}" ]; then
            if [ -f "index.html" ]; then
              BUILD_DIR="."
              echo "BUILD_DIR=." >> $GITHUB_ENV
              echo "âœ… Using current directory for static site"
            else
              echo "âŒ No build output directory found"
              echo "Available directories:"
              ls -la
              exit 1
            fi
          fi

          # List contents of chosen build directory
          echo "ğŸ“„ Build directory contents:"
          ls -la "${BUILD_DIR}"

      - name: Deploy to Netlify (if build succeeded)
        if: env.PREVIEW_BUILD_SUCCESS == 'true'
        run: |
          echo "ğŸš€ Installing and using Netlify CLI directly..."
          npm install -g netlify-cli@17.10.1

          # Deploy and capture output
          netlify deploy --dir=${{ env.BUILD_DIR }} --json > deploy_output.json

          # Extract URLs from output
          cat deploy_output.json
          DEPLOY_URL=$(cat deploy_output.json | grep -o '"deploy_url":"[^"]*' | cut -d'"' -f4)

          if [ -n "$DEPLOY_URL" ]; then
            echo "NETLIFY_URL=$DEPLOY_URL" >> $GITHUB_ENV
            echo "âœ… Deployed to: $DEPLOY_URL"
          else
            echo "âš ï¸ Could not extract deployment URL"
            cat deploy_output.json
          fi
        env:
          NETLIFY_SITE_ID: ${{ secrets.NETLIFY_SITE_ID }}
          NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN }}

      - name: Extract Netlify deployment URL
        if: env.PREVIEW_BUILD_SUCCESS == 'true'
        run: |
          # Extract preview URL from environment variable set in previous step
          DEPLOY_URL="$NETLIFY_URL"

          if [ -n "$DEPLOY_URL" ]; then
            echo "âœ… Preview deployed: $DEPLOY_URL"
            echo "PREVIEW_URL=$DEPLOY_URL" >> $GITHUB_ENV
          else
            echo "âš ï¸ No deployment URL received from Netlify"
            echo "Checking for deploy_output.json..."
            if [ -f "deploy_output.json" ]; then
              echo "Deploy output contents:"
              cat deploy_output.json

              # Try alternative JSON parsing methods
              DEPLOY_URL=$(cat deploy_output.json | jq -r '.deploy_url // empty' 2>/dev/null || echo "")
              if [ -z "$DEPLOY_URL" ]; then
                DEPLOY_URL=$(cat deploy_output.json | grep -o 'https://[^"]*\.netlify\.app' | head -1 || echo "")
              fi

              if [ -n "$DEPLOY_URL" ]; then
                echo "âœ… Extracted URL: $DEPLOY_URL"
                echo "PREVIEW_URL=$DEPLOY_URL" >> $GITHUB_ENV
              else
                echo "âŒ Could not extract URL from deploy output"
              fi
            else
              echo "âŒ deploy_output.json not found"
            fi
          fi

      - name: Setup Browserbase for screenshot generation
        if: env.PREVIEW_URL != ''
        run: |
          echo "ğŸ“¸ Setting up Browserbase for screenshot generation..."
          echo "âœ… Browserbase ready - using cloud browser infrastructure"

      - name: Generate screenshot and upload to CDN
        if: env.PREVIEW_URL != ''
        run: |
          echo "ğŸ“¸ Generating screenshot of deployed site with Browserbase..."

          # Wait for deployment to be ready
          sleep 5

          # Create screenshot script using Browserbase
          cat > screenshot.js << 'EOF'
          import { chromium } from 'playwright-core';
          import FormData from 'form-data';
          import fetch from 'node-fetch';
          import fs from 'fs';

          // Browserbase SDK (inline for simplicity)
          class Browserbase {
            constructor(options) {
              this.apiKey = options.apiKey;
              this.baseUrl = 'https://api.browserbase.com/v1';
            }

            async createSession(options) {
              const response = await fetch(`${this.baseUrl}/sessions`, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'x-bb-api-key': this.apiKey,
                },
                body: JSON.stringify({
                  projectId: options.projectId,
                }),
              });
              return await response.json();
            }
          }

          (async () => {
            console.log('ğŸš€ Creating Browserbase session...');

            if (!process.env.BROWSERBASE_API_KEY) {
              console.error('âŒ BROWSERBASE_API_KEY not found');
              process.exit(1);
            }

            if (!process.env.BROWSERBASE_PROJECT_ID) {
              console.error('âŒ BROWSERBASE_PROJECT_ID not found');
              process.exit(1);
            }

            const bb = new Browserbase({
              apiKey: process.env.BROWSERBASE_API_KEY
            });

            const session = await bb.createSession({
              projectId: process.env.BROWSERBASE_PROJECT_ID,
            });

            if (!session.connectUrl) {
              console.error('âŒ Failed to create Browserbase session:', session);
              process.exit(1);
            }

            console.log('âœ… Browserbase session created, connecting...');

            // Connect to remote browser
            const browser = await chromium.connectOverCDP(session.connectUrl);
            const defaultContext = browser.contexts()[0];
            const page = defaultContext.pages()[0];

            console.log('ğŸ“„ Navigating to:', process.env.PREVIEW_URL);
            await page.goto(process.env.PREVIEW_URL, {
              waitUntil: 'domcontentloaded',
              timeout: 20000
            });

            // Wait for page to stabilize
            await page.waitForTimeout(2000);

            console.log('ğŸ“¸ Capturing screenshot with CDP...');

            // Use CDP for faster, more reliable screenshots
            const client = await defaultContext.newCDPSession(page);
            const { data } = await client.send('Page.captureScreenshot', {
              format: 'jpeg',
              quality: 90,
              captureBeyondViewport: true,
            });

            const screenshot = Buffer.from(data, 'base64');

            await browser.close();
            console.log('âœ… Screenshot captured successfully');

            // Upload to Uploadcare
            console.log('â˜ï¸ Uploading to Uploadcare CDN...');

            const form = new FormData();
            form.append('UPLOADCARE_PUB_KEY', process.env.UPLOADCARE_PUBLIC_KEY);
            form.append('file', screenshot, {
              filename: 'screenshot.jpg',
              contentType: 'image/jpeg'
            });

            const response = await fetch('https://upload.uploadcare.com/base/', {
              method: 'POST',
              body: form
            });

            const result = await response.json();
            if (result.file) {
              const cdnUrl = `https://ucarecdn.com/${result.file}/`;
              console.log('âœ… Screenshot uploaded:', cdnUrl);
              console.log(`SCREENSHOT_URL=${cdnUrl}`);

              // Set environment variable for next steps
              fs.appendFileSync(process.env.GITHUB_ENV, `SCREENSHOT_URL=${cdnUrl}\n`);
            } else {
              console.error('âŒ Upload failed:', result);
              process.exit(1);
            }
          })();
          EOF

          # Install required packages (much lighter without full Playwright)
          npm install playwright-core form-data node-fetch@2

          # Run screenshot script
          node screenshot.js || {
            echo "âš ï¸ Screenshot generation failed, but deployment was successful"
            echo "SCREENSHOT_URL=" >> $GITHUB_ENV
          }
        env:
          UPLOADCARE_PUBLIC_KEY: ${{ secrets.UPLOADCARE_PUBLIC_KEY }}
          BROWSERBASE_API_KEY: ${{ secrets.BROWSERBASE_API_KEY }}
          BROWSERBASE_PROJECT_ID: ${{ secrets.BROWSERBASE_PROJECT_ID }}

      - name: Update commit with preview info
        if: env.PREVIEW_URL != ''
        run: |
          echo "ğŸ“ Adding preview info to commit..."

          # Amend commit with preview information
          UPDATED_COMMIT_MSG="feat: ${{ github.event.inputs.request }}

          ğŸ¤– Generated with VGit AI (Claude Code)

          Branch: ${{ github.event.inputs.branch_name }}
          Requested by: ${{ github.event.inputs.username }}
          Preview: ${{ env.PREVIEW_URL }}

          ---PREVIEW-INFO---
          Preview URL: ${{ env.PREVIEW_URL }}
          Screenshot URL: ${{ env.SCREENSHOT_URL }}
          "

          git commit --amend -m "$UPDATED_COMMIT_MSG"
          git push origin "${{ github.event.inputs.branch_name }}" --force-with-lease

      - name: Create workspace node update payload
        run: |
          echo "ğŸ—ï¸ Creating workspace node update payload..."

          # Get commit SHA
          COMMIT_SHA=$(git rev-parse HEAD)

          # Create payload for VGit workspace node creation
          cat > workspace_node_payload.json << EOF
          {
            "repository_full_name": "${{ github.repository }}",
            "branch_name": "${{ github.event.inputs.branch_name }}",
            "commit_sha": "$COMMIT_SHA",
            "username": "${{ github.event.inputs.username }}",
            "current_node": "${{ github.event.inputs.current_node }}",
            "preview_url": "${{ env.PREVIEW_URL }}",
            "screenshot_url": "${{ env.SCREENSHOT_URL }}",
            "workflow_run_id": "${{ github.run_id }}",
            "created_at": "$(date -u +%Y-%m-%dT%H:%M:%S.%3NZ)"
          }
          EOF

          echo "âœ… Workspace node payload created"

      - name: Upload workspace payload as artifact
        uses: actions/upload-artifact@v4
        with:
          name: workspace-node-payload
          path: workspace_node_payload.json
          retention-days: 7

      - name: Summary
        run: |
          echo "ğŸ‰ Feature creation completed successfully!"
          echo ""
          echo "ğŸ“‹ Summary:"
          echo "- Branch: ${{ github.event.inputs.branch_name }}"
          echo "- Feature: ${{ github.event.inputs.request }}"
          echo "- Repository: ${{ github.repository }}"
          echo "- Commit SHA: $(git rev-parse HEAD)"
          if [ -n "${{ env.PREVIEW_URL }}" ]; then
            echo "- Preview URL: ${{ env.PREVIEW_URL }}"
          fi
          if [ -n "${{ env.SCREENSHOT_URL }}" ]; then
            echo "- Screenshot URL: ${{ env.SCREENSHOT_URL }}"
          fi
          echo "- Workflow Run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
