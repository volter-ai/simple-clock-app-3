name: VGit Deploy Preview
on:
  workflow_dispatch:
    inputs:
      branch_name:
        description: "Branch to deploy"
        required: true
        type: string
      deployment_type:
        description: "Type of deployment"
        required: false
        type: choice
        default: "preview"
        options:
          - "preview"
          - "production"
      username:
        description: "GitHub username"
        required: true
        type: string
      force_rebuild:
        description: "Force rebuild even if no changes"
        required: false
        type: boolean
        default: false
      environment:
        description: "GitHub environment to use for deployment"
        required: false
        type: string
      runtime_vars:
        description: "Comma-separated list of env var names to expose at runtime"
        required: false
        type: string
        default: ""

jobs:
  deploy-preview:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    environment: ${{ github.event.inputs.environment || '' }}

    steps:
      - name: Validate inputs
        run: |
          if [ -z "${{ github.event.inputs.branch_name }}" ]; then
            echo "âŒ Branch name is required"
            exit 1
          fi
          echo "âœ… Inputs validated"
          echo "Branch: ${{ github.event.inputs.branch_name }}"
          echo "Type: ${{ github.event.inputs.deployment_type }}"

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.branch_name }}
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Verify branch exists
        run: |
          echo "ðŸ” Verifying branch exists..."
          CURRENT_BRANCH=$(git branch --show-current)
          if [ "$CURRENT_BRANCH" != "${{ github.event.inputs.branch_name }}" ]; then
            echo "âŒ Failed to checkout branch '${{ github.event.inputs.branch_name }}'"
            echo "Current branch: $CURRENT_BRANCH"
            exit 1
          fi
          echo "âœ… Successfully checked out branch: ${{ github.event.inputs.branch_name }}"

      - name: Detect project type and build configuration
        run: |
          echo "ðŸ” Detecting project type..."

          if [ -f "package.json" ]; then
            echo "ðŸ“¦ Node.js project detected"
            echo "PROJECT_TYPE=nodejs" >> $GITHUB_ENV
            
            # Check for build script
            if grep -q '"build"' package.json; then
              BUILD_SCRIPT=$(jq -r '.scripts.build' package.json)
              echo "BUILD_SCRIPT=$BUILD_SCRIPT" >> $GITHUB_ENV
              echo "HAS_BUILD_SCRIPT=true" >> $GITHUB_ENV
              echo "âœ… Build script found: $BUILD_SCRIPT"
            else
              echo "âš ï¸ No build script found in package.json"
              echo "HAS_BUILD_SCRIPT=false" >> $GITHUB_ENV
            fi
            
            # Check for dev script
            if grep -q '"dev"' package.json; then
              DEV_SCRIPT=$(jq -r '.scripts.dev' package.json)
              echo "DEV_SCRIPT=$DEV_SCRIPT" >> $GITHUB_ENV
              echo "HAS_DEV_SCRIPT=true" >> $GITHUB_ENV
              echo "âœ… Dev script found: $DEV_SCRIPT"
            fi
            
            # Detect framework
            if jq -e '.dependencies.react' package.json > /dev/null 2>&1; then
              echo "FRAMEWORK=react" >> $GITHUB_ENV
              echo "âš›ï¸ React project detected"
            elif jq -e '.dependencies.vue' package.json > /dev/null 2>&1; then
              echo "FRAMEWORK=vue" >> $GITHUB_ENV
              echo "ðŸŸ¢ Vue project detected"
            elif jq -e '.dependencies.next' package.json > /dev/null 2>&1; then
              echo "FRAMEWORK=nextjs" >> $GITHUB_ENV
              echo "ðŸ”¼ Next.js project detected"
            elif jq -e '.dependencies.angular' package.json > /dev/null 2>&1; then
              echo "FRAMEWORK=angular" >> $GITHUB_ENV
              echo "ðŸ…°ï¸ Angular project detected"
            else
              echo "FRAMEWORK=vanilla" >> $GITHUB_ENV
              echo "ðŸŒ Vanilla JavaScript project detected"
            fi
            
          elif [ -f "index.html" ]; then
            echo "ðŸŒ Static HTML project detected"
            echo "PROJECT_TYPE=static" >> $GITHUB_ENV
            echo "HAS_BUILD_SCRIPT=false" >> $GITHUB_ENV
            
          else
            echo "â“ Unknown project type"
            echo "PROJECT_TYPE=unknown" >> $GITHUB_ENV
            echo "HAS_BUILD_SCRIPT=false" >> $GITHUB_ENV
          fi

      - name: Setup Node.js (if needed)
        if: env.PROJECT_TYPE == 'nodejs'
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"

      - name: Install dependencies
        if: env.PROJECT_TYPE == 'nodejs'
        run: |
          echo "ðŸ“¦ Installing dependencies..."
          npm install

      - name: Export all secrets as environment variables dynamically
        run: |
          echo "ðŸ” Dynamically exporting all secrets as environment variables..."
          if [ "$SECRETS_JSON" != "null" ] && [ "$SECRETS_JSON" != "" ]; then
            echo "ðŸ“‹ Processing secrets from environment..."
            echo "$SECRETS_JSON" | jq -r 'to_entries | .[] | "\(.key)=\(.value)"' >> $GITHUB_ENV
            echo "âœ… All secrets exported as environment variables"
          else
            echo "â„¹ï¸ No secrets found in environment"
          fi
        env:
          SECRETS_JSON: ${{ toJson(secrets) }}

      - name: Prepare runtime environment variables
        run: |
          echo "ðŸ”§ Preparing runtime environment variables..."
          
          # Debug: Show which environment variables are available (names only, not values)
          echo "ðŸ” Available environment variables (for debugging):"
          env | grep -E '^(ANTHROPIC|SUBSCRIBE|OPENAI|CUSTOM)' | cut -d'=' -f1 | sort || echo "No addon-related environment variables found"
          
          # Parse runtime_vars input (comma-separated list)
          RUNTIME_VARS="${{ github.event.inputs.runtime_vars }}"
          
          if [ -n "$RUNTIME_VARS" ] && [ "$RUNTIME_VARS" != "" ]; then
            echo "ðŸ“‹ Runtime variables to expose: $RUNTIME_VARS"
            
            # Create a script to export VITE_ prefixed versions
            echo "#!/bin/bash" > runtime_env_setup.sh
            echo "# Auto-generated runtime environment variables" >> runtime_env_setup.sh
            
            # Split comma-separated values and create VITE_ versions
            IFS=',' read -ra VARS <<< "$RUNTIME_VARS"
            for var in "${VARS[@]}"; do
              # Trim whitespace
              var=$(echo "$var" | xargs)
              
              if [ -n "$var" ]; then
                # Convert to uppercase
                upper_var=$(echo "$var" | tr '[:lower:]' '[:upper:]')
                vite_var="VITE_$upper_var"
                
                echo "Creating runtime variable: $upper_var -> $vite_var"
                
                # Add export statement to script
                echo "if [ -n \"\${$upper_var}\" ]; then" >> runtime_env_setup.sh
                echo "  export $vite_var=\"\${$upper_var}\"" >> runtime_env_setup.sh
                echo "  echo \"âœ… Exposed $upper_var as $vite_var\"" >> runtime_env_setup.sh
                echo "else" >> runtime_env_setup.sh
                echo "  echo \"âš ï¸ $upper_var not found in environment\"" >> runtime_env_setup.sh
                echo "fi" >> runtime_env_setup.sh
              fi
            done
            
            # Make the script executable
            chmod +x runtime_env_setup.sh
            
            echo "ðŸ” Runtime environment setup script created:"
            cat runtime_env_setup.sh
          else
            echo "â„¹ï¸ No runtime variables specified, skipping VITE_ prefix setup"
            echo "#!/bin/bash" > runtime_env_setup.sh
            echo "echo 'No runtime variables to expose'" >> runtime_env_setup.sh
            chmod +x runtime_env_setup.sh
          fi

      - name: Run pre-build checks
        if: env.PROJECT_TYPE == 'nodejs'
        run: |
          echo "ðŸ”§ Running pre-build checks..."

          # Run linting if available
          if npm run lint --silent > /dev/null 2>&1; then
            echo "ðŸ” Running linter..."
            npm run lint || {
              echo "âš ï¸ Linting issues found (continuing with deployment)"
              echo "LINT_ISSUES=true" >> $GITHUB_ENV
            }
          fi

          # Run type checking if available
          if npm run type-check --silent > /dev/null 2>&1 || npm run tsc --silent > /dev/null 2>&1; then
            echo "ðŸ“ Running type checks..."
            (npm run type-check || npm run tsc) || {
              echo "âš ï¸ Type checking issues found (continuing with deployment)"
              echo "TYPE_ISSUES=true" >> $GITHUB_ENV
            }
          fi

      - name: Build project
        if: env.HAS_BUILD_SCRIPT == 'true'
        run: |
          echo "ðŸ—ï¸ Building project..."
          
          echo "ðŸ” Re-exporting secrets for build step..."
          if [ "$SECRETS_JSON" != "null" ] && [ "$SECRETS_JSON" != "" ]; then
            eval $(echo "$SECRETS_JSON" | jq -r 'to_entries | .[] | "export \(.key)=\"\(.value)\""')
            echo "âœ… Secrets re-exported for build step"
          fi
          
          echo "ðŸ”§ Sourcing runtime environment variables before build..."
          source ./runtime_env_setup.sh
          
          npm run build || {
            echo "âŒ Build failed"
            exit 1
          }
          echo "âœ… Build completed successfully"
          echo "BUILD_SUCCESS=true" >> $GITHUB_ENV
        env:
          SECRETS_JSON: ${{ toJson(secrets) }}

      - name: Detect build output directory
        run: |
          echo "ðŸ“ Detecting build output directory..."
          BUILD_DIR="dist"  # Default value

          # Check for custom build directory from secret first
          if [ -n "${{ secrets.CUSTOM_BUILD_DIR }}" ]; then
            CUSTOM_DIR="${{ secrets.CUSTOM_BUILD_DIR }}"
            if [ -d "$CUSTOM_DIR" ] && [ "$(ls -A $CUSTOM_DIR 2>/dev/null)" ]; then
              BUILD_DIR="$CUSTOM_DIR"
              echo "BUILD_DIR=$BUILD_DIR" >> $GITHUB_ENV
              echo "âœ… Using custom build directory: $BUILD_DIR"
              ls -la "$BUILD_DIR"
              exit 0
            else
              echo "âš ï¸ Custom build directory '$CUSTOM_DIR' not found or empty, falling back to auto-detection"
            fi
          fi

          # Auto-detect common build output directories
          BUILD_DIRS=("dist" "build" "_site" "out" ".next" "public")

          for dir in "${BUILD_DIRS[@]}"; do
            if [ -d "$dir" ] && [ "$(ls -A $dir 2>/dev/null)" ]; then
              BUILD_DIR="$dir"
              echo "BUILD_DIR=$BUILD_DIR" >> $GITHUB_ENV
              echo "âœ… Build output directory found: $BUILD_DIR"
              break
            fi
          done

          # If no build directory found, use current directory for static sites
          if [ -z "$BUILD_DIR" ]; then
            if [ -f "index.html" ]; then
              BUILD_DIR="."
              echo "BUILD_DIR=$BUILD_DIR" >> $GITHUB_ENV
              echo "âœ… Using current directory for static site"
            else
              echo "âŒ No build output directory found"
              echo "Available directories:"
              ls -la
              exit 1
            fi
          fi

          # List contents of chosen build directory
          echo "ðŸ“„ Build directory contents:"
          ls -la "$BUILD_DIR"

      - name: Install Netlify CLI
        run: |
          echo "ðŸŒ Installing Netlify CLI..."
          npm install -g netlify-cli@17.10.1
          netlify --version

      - name: Deploy to Netlify
        env:
          NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN }}
          NETLIFY_SITE_ID: ${{ secrets.NETLIFY_SITE_ID }}
        run: |
          if [ -z "$NETLIFY_AUTH_TOKEN" ]; then
            echo "âŒ NETLIFY_AUTH_TOKEN secret is not configured"
            echo "Please add your Netlify auth token to repository secrets"
            exit 1
          fi

          if [ -z "$NETLIFY_SITE_ID" ]; then
            echo "âŒ NETLIFY_SITE_ID secret is not configured"
            echo "Please add your Netlify site ID to repository secrets"
            exit 1
          fi

          echo "ðŸš€ Deploying to Netlify..."

          # Determine deployment type
          if [ "${{ github.event.inputs.deployment_type }}" = "production" ]; then
            echo "ðŸŒŸ Deploying to production..."
            DEPLOY_OUTPUT=$(netlify deploy --dir="${BUILD_DIR}" --prod --json) || {
              echo "âŒ Production deployment failed"
              exit 1
            }
          else
            # Determine alias to use (prioritize NETLIFY_DEPLOY_ALIAS_NAME)
            if [ -n "${{ secrets.NETLIFY_DEPLOY_ALIAS_NAME }}" ]; then
              echo "ðŸ” Using custom deploy alias: ${{ secrets.NETLIFY_DEPLOY_ALIAS_NAME }}"
              DEPLOY_ALIAS="${{ secrets.NETLIFY_DEPLOY_ALIAS_NAME }}"
            else
              echo "ðŸ” Using branch name as alias: ${{ github.event.inputs.branch_name }}"
              DEPLOY_ALIAS="${{ github.event.inputs.branch_name }}"
            fi

            echo "ðŸš€ Deploying preview with alias: ${DEPLOY_ALIAS}"
            DEPLOY_OUTPUT=$(netlify deploy --dir="${BUILD_DIR}" --alias="${DEPLOY_ALIAS}" --json) || {
              echo "âŒ Preview deployment failed"
              exit 1
            }
          fi

          echo "âœ… Deployment completed successfully"

          # Parse deployment output
          DEPLOY_URL=$(echo "$DEPLOY_OUTPUT" | jq -r '.deploy_url // .url // empty')
          DEPLOY_ID=$(echo "$DEPLOY_OUTPUT" | jq -r '.deploy_id // empty')

          if [ -n "$DEPLOY_URL" ]; then
            echo "DEPLOY_URL=$DEPLOY_URL" >> $GITHUB_ENV
            echo "ðŸŒ Deployment URL: $DEPLOY_URL"
          fi

          if [ -n "$DEPLOY_ID" ]; then
            echo "DEPLOY_ID=$DEPLOY_ID" >> $GITHUB_ENV
            echo "ðŸ†” Deploy ID: $DEPLOY_ID"
          fi

      - name: Run smoke tests (if applicable)
        if: env.DEPLOY_URL != ''
        run: |
          echo "ðŸ§ª Running smoke tests on deployed site..."

          # Wait a moment for deployment to be ready
          sleep 5

          # Basic connectivity test
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "${{ env.DEPLOY_URL }}" || echo "000")

          if [ "$HTTP_STATUS" = "200" ]; then
            echo "âœ… Site is accessible (HTTP $HTTP_STATUS)"
            echo "SMOKE_TEST_PASSED=true" >> $GITHUB_ENV
          else
            echo "âš ï¸ Site returned HTTP $HTTP_STATUS"
            echo "SMOKE_TEST_PASSED=false" >> $GITHUB_ENV
          fi

          # Check for basic HTML structure
          if curl -s "${{ env.DEPLOY_URL }}" | grep -q "<html"; then
            echo "âœ… Valid HTML structure detected"
          else
            echo "âš ï¸ No HTML structure found"
          fi

      - name: Generate screenshot (if applicable)
        if: env.DEPLOY_URL != '' && env.SMOKE_TEST_PASSED == 'true'
        run: |
          echo "ðŸ“¸ Generating screenshot with Browserbase..."

          # Create screenshot script using Browserbase
          cat > screenshot.js << 'EOF'
          import { chromium } from 'playwright-core';
          import fs from 'fs';

          // Browserbase SDK (inline for simplicity)
          class Browserbase {
            constructor(options) {
              this.apiKey = options.apiKey;
              this.baseUrl = 'https://api.browserbase.com/v1';
            }

            async createSession(options) {
              const response = await fetch(`${this.baseUrl}/sessions`, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'x-bb-api-key': this.apiKey,
                },
                body: JSON.stringify({
                  projectId: options.projectId,
                }),
              });
              return await response.json();
            }
          }

          (async () => {
            console.log('ðŸš€ Creating Browserbase session...');

            if (!process.env.BROWSERBASE_API_KEY || !process.env.BROWSERBASE_PROJECT_ID) {
              console.error('âŒ Browserbase credentials not found, falling back to error');
              process.exit(0); // Don't fail the workflow
            }

            try {
              const bb = new Browserbase({
                apiKey: process.env.BROWSERBASE_API_KEY
              });

              const session = await bb.createSession({
                projectId: process.env.BROWSERBASE_PROJECT_ID,
              });

              if (!session.connectUrl) {
                throw new Error('Failed to create Browserbase session');
              }

              console.log('âœ… Browserbase session created, connecting...');

              // Connect to remote browser
              const browser = await chromium.connectOverCDP(session.connectUrl);
              const defaultContext = browser.contexts()[0];
              const page = defaultContext.pages()[0];

              console.log('ðŸ“„ Navigating to:', process.env.DEPLOY_URL);
              await page.goto(process.env.DEPLOY_URL, {
                waitUntil: 'domcontentloaded',
                timeout: 15000
              });

              // Wait for page to stabilize
              await page.waitForTimeout(1500);

              console.log('ðŸ“¸ Capturing screenshot with CDP...');

              // Use CDP for faster screenshots
              const client = await defaultContext.newCDPSession(page);
              const { data } = await client.send('Page.captureScreenshot', {
                format: 'png',
                captureBeyondViewport: true,
              });

              const screenshot = Buffer.from(data, 'base64');
              fs.writeFileSync('screenshot.png', screenshot);

              await browser.close();
              console.log('âœ… Screenshot generated successfully');

            } catch (error) {
              console.error('âš ï¸ Screenshot generation failed:', error.message);
              process.exit(0); // Don't fail the workflow
            }
          })();
          EOF

          # Install required packages (much lighter)
          npm install playwright-core

          # Run screenshot script
          node screenshot.js

          if [ -f "screenshot.png" ]; then
            echo "âœ… Screenshot generated successfully"
            echo "SCREENSHOT_GENERATED=true" >> $GITHUB_ENV
          fi
        env:
          BROWSERBASE_API_KEY: ${{ secrets.BROWSERBASE_API_KEY }}
          BROWSERBASE_PROJECT_ID: ${{ secrets.BROWSERBASE_PROJECT_ID }}

      - name: Create deployment payload
        run: |
          echo "ðŸ“¦ Creating deployment payload..."

          # Create payload for VGit
          cat > deployment_payload.json << EOF
          {
            "branch_name": "${{ github.event.inputs.branch_name }}",
            "deployment_type": "${{ github.event.inputs.deployment_type }}",
            "repository_full_name": "${{ github.repository }}",
            "username": "${{ github.event.inputs.username }}",
            "project_name": "${{ github.event.inputs.project_name }}",
            "project_type": "${{ env.PROJECT_TYPE }}",
            "framework": "${{ env.FRAMEWORK }}",
            "build_success": "${{ env.BUILD_SUCCESS == 'true' }}",
            "deploy_url": "${{ env.DEPLOY_URL }}",
            "deploy_id": "${{ env.DEPLOY_ID }}",
            "smoke_test_passed": "${{ env.SMOKE_TEST_PASSED == 'true' }}",
            "screenshot_generated": "${{ env.SCREENSHOT_GENERATED == 'true' }}",
            "lint_issues": "${{ env.LINT_ISSUES == 'true' }}",
            "type_issues": "${{ env.TYPE_ISSUES == 'true' }}",
            "workflow_run_id": "${{ github.run_id }}",
            "commit_sha": "${{ github.sha }}",
            "created_at": "$(date -u +%Y-%m-%dT%H:%M:%S.%3NZ)"
          }
          EOF

          echo "âœ… Deployment payload created"

      - name: Upload deployment artifacts
        uses: actions/upload-artifact@v4
        with:
          name: deployment-results
          path: |
            deployment_payload.json
            screenshot.png
          retention-days: 30

      - name: Summary
        run: |
          echo "ðŸŽ‰ Deployment completed!"
          echo ""
          echo "ðŸ“‹ Summary:"
          echo "- Branch: ${{ github.event.inputs.branch_name }}"
          echo "- Type: ${{ github.event.inputs.deployment_type }}"
          echo "- Repository: ${{ github.repository }}"
          echo "- Project Type: ${{ env.PROJECT_TYPE }}"
          if [ -n "${{ env.FRAMEWORK }}" ]; then
            echo "- Framework: ${{ env.FRAMEWORK }}"
          fi
          echo "- Build Success: ${{ env.BUILD_SUCCESS == 'true' }}"
          if [ -n "${{ env.DEPLOY_URL }}" ]; then
            echo "- Deployment URL: ${{ env.DEPLOY_URL }}"
          fi
          echo "- Smoke Tests: ${{ env.SMOKE_TEST_PASSED == 'true' }}"
          echo "- Screenshot: ${{ env.SCREENSHOT_GENERATED == 'true' }}"
          echo "- Workflow Run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"

          if [ "${{ env.LINT_ISSUES }}" = "true" ]; then
            echo ""
            echo "âš ï¸ Linting issues detected (see build logs)"
          fi

          if [ "${{ env.TYPE_ISSUES }}" = "true" ]; then
            echo ""
            echo "âš ï¸ Type checking issues detected (see build logs)"
          fi

          echo ""
          echo "ðŸ”— Access your deployed site: ${{ env.DEPLOY_URL }}"
